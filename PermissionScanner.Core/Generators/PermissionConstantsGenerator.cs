using System.Text;
using PermissionScanner.Core.Analyzers;
using PermissionScanner.Core.Models;

namespace PermissionScanner.Core.Generators;

/// <summary>
/// Generates C# code for Permissions.cs constants class.
/// </summary>
public static class PermissionConstantsGenerator
{
    /// <summary>
    /// Generates the Permissions.cs file content with permission constants.
    /// Merges with existing constants to preserve manual additions.
    /// </summary>
    /// <param name="permissions">List of permissions to generate</param>
    /// <param name="existingContent">Existing file content to merge with</param>
    /// <param name="namespaceName">Namespace for the generated constants (default: KS.PlatformServices.Constants)</param>
    public static string GenerateFileContent(List<PermissionDefinition> permissions, string? existingContent = null, string? namespaceName = null)
    {
        // Extract existing constants from file
        var existingConstants = ExtractExistingConstants(existingContent);
        
        // Add default manual permissions if they don't exist (only for PlatformServices)
        var defaultPermissions = GetDefaultManualPermissions();
        if (namespaceName == null || namespaceName.Contains("PlatformServices"))
        {
            foreach (var defaultPerm in defaultPermissions)
            {
                if (!existingConstants.ContainsKey(defaultPerm.Key))
                {
                    existingConstants[defaultPerm.Key] = defaultPerm.Value;
                }
            }
        }
        
        // Deduplicate: if multiple permissions generate the same constant name, keep the first one
        var uniquePermissions = new Dictionary<string, PermissionDefinition>();
        var constantNameCollisions = new Dictionary<string, List<PermissionDefinition>>();
        
        foreach (var permission in permissions)
        {
            if (!uniquePermissions.ContainsKey(permission.ConstantName))
            {
                uniquePermissions[permission.ConstantName] = permission;
            }
            else
            {
                // Track collisions for reporting
                if (!constantNameCollisions.ContainsKey(permission.ConstantName))
                {
                    constantNameCollisions[permission.ConstantName] = new List<PermissionDefinition> 
                    { 
                        uniquePermissions[permission.ConstantName] 
                    };
                }
                constantNameCollisions[permission.ConstantName].Add(permission);
            }
        }
        
        // Report collisions
        if (constantNameCollisions.Count > 0)
        {
            Console.WriteLine($"⚠️  Warning: {constantNameCollisions.Count} constant name collision(s) detected:");
            foreach (var collision in constantNameCollisions)
            {
                Console.WriteLine($"  Constant '{collision.Key}' used by {collision.Value.Count} permissions:");
                foreach (var perm in collision.Value)
                {
                    Console.WriteLine($"    - {perm.PermissionName}");
                }
            }
        }
        
        // Merge: preserve existing constants that aren't in generated list
        foreach (var existing in existingConstants)
        {
            if (!uniquePermissions.ContainsKey(existing.Key))
            {
                // This is a manually added constant, preserve it
                // We'll add it to the appropriate domain
                var manualPermission = new PermissionDefinition
                {
                    PermissionName = existing.Value.PermissionName,
                    ConstantName = existing.Key,
                    Description = existing.Value.Description ?? string.Empty,
                    Domain = existing.Value.Domain ?? "Other",
                    Endpoints = existing.Value.Endpoints ?? new List<string>()
                };
                uniquePermissions[existing.Key] = manualPermission;
            }
        }
        
        var sb = new StringBuilder();
        
        // Use provided namespace or default to PlatformServices
        var ns = namespaceName ?? "KS.PlatformServices.Constants";
        sb.AppendLine($"namespace {ns};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("/// Permission constants for the Intelligent Krono Application.");
        sb.AppendLine("/// Auto-generated by Permission Scanner Tool - DO NOT EDIT MANUALLY");
        sb.AppendLine($"/// Last Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine("/// To regenerate: dotnet tool run permission-scanner generate");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("public static class Permissions");
        sb.AppendLine("{");

        // Group by domain
        var groupedByDomain = uniquePermissions.Values
            .GroupBy(p => p.Domain)
            .OrderBy(g => g.Key)
            .ToList();

        foreach (var domainGroup in groupedByDomain)
        {
            sb.AppendLine($"    #region {domainGroup.Key} Permissions");
            sb.AppendLine();

            var sortedPermissions = domainGroup.OrderBy(p => p.PermissionName).ToList();
            
            foreach (var permission in sortedPermissions)
            {
                // XML comment
                sb.AppendLine("    /// <summary>");
                if (!string.IsNullOrEmpty(permission.Description))
                {
                    sb.AppendLine($"    /// {permission.Description}.");
                }
                
                if (permission.Endpoints.Count > 0)
                {
                    sb.AppendLine("    /// Endpoints: " + string.Join(", ", permission.Endpoints.Take(3)));
                    if (permission.Endpoints.Count > 3)
                    {
                        sb.AppendLine($"    /// (+ {permission.Endpoints.Count - 3} more)");
                    }
                }
                sb.AppendLine("    /// </summary>");
                
                // Constant declaration
                sb.AppendLine($"    public const string {permission.ConstantName} = \"{permission.PermissionName}\";");
                sb.AppendLine();
            }

            sb.AppendLine("    #endregion");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        return sb.ToString();
    }
    
    /// <summary>
    /// Returns default manual permissions that must always be present.
    /// These are manually defined permissions not discovered by the scanner.
    /// </summary>
    private static Dictionary<string, (string PermissionName, string? Description, string? Domain, List<string> Endpoints)> GetDefaultManualPermissions()
    {
        return new Dictionary<string, (string, string?, string?, List<string>)>
        {
            {
                "DiscountApprovalsView",
                ("discount-approvals:view", "View discount approvals", "Approvals", new List<string>())
            },
            {
                "DiscountApprovalsApprove",
                ("discount-approvals:approve", "Approve discount approvals", "Approvals", new List<string>())
            },
            {
                "DiscountApprovalsReject",
                ("discount-approvals:reject", "Reject discount approvals", "Approvals", new List<string>())
            }
        };
    }
    
    /// <summary>
    /// Extracts existing constants from file content.
    /// </summary>
    private static Dictionary<string, (string PermissionName, string? Description, string? Domain, List<string> Endpoints)> ExtractExistingConstants(string? content)
    {
        var constants = new Dictionary<string, (string, string?, string?, List<string>)>();
        
        if (string.IsNullOrEmpty(content))
            return constants;
        
        var lines = content.Split('\n');
        string? currentDescription = null;
        string? currentDomain = null;
        var currentEndpoints = new List<string>();
        var capturingComment = false;
        
        for (int i = 0; i < lines.Length; i++)
        {
            var line = lines[i].Trim();
            
            // Detect region
            if (line.Contains("#region"))
            {
                var regionMatch = System.Text.RegularExpressions.Regex.Match(line, @"#region\s+(.+?)\s+Permissions");
                if (regionMatch.Success)
                {
                    currentDomain = regionMatch.Groups[1].Value;
                }
                continue;
            }
            
            if (line.Contains("#endregion"))
            {
                currentDomain = null;
                continue;
            }
            
            // Capture XML comments
            if (line.StartsWith("///"))
            {
                capturingComment = true;
                var commentText = line.Substring(3).Trim();
                if (commentText.StartsWith("<summary>"))
                    continue;
                if (commentText.StartsWith("</summary>"))
                {
                    capturingComment = false;
                    continue;
                }
                if (capturingComment && !string.IsNullOrWhiteSpace(commentText))
                {
                    if (string.IsNullOrEmpty(currentDescription))
                        currentDescription = commentText;
                    else
                        currentDescription += " " + commentText;
                    
                    // Extract endpoints
                    if (commentText.StartsWith("Endpoints:"))
                    {
                        var endpointsText = commentText.Substring("Endpoints:".Length).Trim();
                        currentEndpoints.AddRange(endpointsText.Split(',').Select(e => e.Trim()));
                    }
                }
                continue;
            }
            
            // Extract constant declaration
            if (line.StartsWith("public const string"))
            {
                var match = System.Text.RegularExpressions.Regex.Match(
                    line,
                    @"public\s+const\s+string\s+(\w+)\s*=\s*""([^""]+)""");
                
                if (match.Success)
                {
                    var constantName = match.Groups[1].Value;
                    var permissionName = match.Groups[2].Value;
                    
                    constants[constantName] = (permissionName, currentDescription, currentDomain, new List<string>(currentEndpoints));
                    
                    // Reset for next constant
                    currentDescription = null;
                    currentEndpoints.Clear();
                }
            }
            else if (!string.IsNullOrWhiteSpace(line))
            {
                // Non-comment, non-constant line - reset
                capturingComment = false;
            }
        }
        
        return constants;
    }

    /// <summary>
    /// Converts discovered endpoints to permission definitions.
    /// Also merges code-referenced permissions to ensure all referenced constants are generated.
    /// </summary>
    public static List<PermissionDefinition> ConvertToPermissions(
        List<DiscoveredEndpoint> endpoints, 
        List<PermissionDefinition>? codeReferencedPermissions = null)
    {
        var permissionMap = new Dictionary<string, PermissionDefinition>();

        // First, add all endpoint-discovered permissions
        foreach (var endpoint in endpoints)
        {
            var key = endpoint.SuggestedPermission;
            
            if (!permissionMap.TryGetValue(key, out var permission))
            {
                permission = new PermissionDefinition
                {
                    PermissionName = endpoint.SuggestedPermission,
                    Resource = endpoint.Resource,
                    Action = endpoint.Action,
                    ConstantName = PermissionNameGenerator.GenerateConstantName(endpoint.SuggestedPermission),
                    Domain = PermissionNameGenerator.DetermineDomain(endpoint.Resource),
                    Endpoints = new List<string>(),
                    Description = GenerateDescription(endpoint.Resource, endpoint.Action)
                };

                permissionMap[key] = permission;
            }

            // Track which services use this permission (for shared vs service-specific classification)
            if (!string.IsNullOrWhiteSpace(endpoint.ServiceName))
            {
                permission.Services.Add(endpoint.ServiceName);
            }

            // Add endpoint reference
            var endpointRef = $"{endpoint.HttpMethod} {endpoint.RouteTemplate}";
            if (!permission.Endpoints.Contains(endpointRef))
            {
                permission.Endpoints.Add(endpointRef);
            }
        }

        // Then, merge code-referenced permissions (add missing ones, merge services for existing ones)
        if (codeReferencedPermissions != null)
        {
            foreach (var codePerm in codeReferencedPermissions)
            {
                // Check if permission already exists by permission name
                if (permissionMap.TryGetValue(codePerm.PermissionName, out var existing))
                {
                    // Merge services
                    foreach (var service in codePerm.Services)
                    {
                        existing.Services.Add(service);
                    }
                    // Merge endpoints/references
                    foreach (var endpoint in codePerm.Endpoints)
                    {
                        if (!existing.Endpoints.Contains(endpoint))
                        {
                            existing.Endpoints.Add(endpoint);
                        }
                    }
                }
                else
                {
                    // Add new permission from code reference
                    permissionMap[codePerm.PermissionName] = codePerm;
                }
            }
        }

        // Classify permissions into shared vs service-specific based on usage
        foreach (var permission in permissionMap.Values)
        {
            permission.Scope = ClassifyScope(permission);
        }

        return permissionMap.Values
            .OrderBy(p => p.Domain)
            .ThenBy(p => p.PermissionName)
            .ToList();
    }

    private static string GenerateDescription(string resource, string action)
    {
        var resourceName = resource.Replace("-", " ").Replace(":", " ");
        var actionName = action switch
        {
            "read" => "View",
            "create" => "Create",
            "update" => "Update",
            "delete" => "Delete",
            "approve" => "Approve",
            "reject" => "Reject",
            _ => action
        };

        return $"{actionName} {resourceName}";
    }

    /// <summary>
    /// Classifies permission scope based on resource naming and service usage.
    /// </summary>
    /// <remarks>
    /// Rules:
    /// 1. Platform-level resources are always shared:
    ///    - resource starts with \"tenant-\", \"platform\", \"rbac\", \"permissions\", or \"roles\"
    /// 2. If a permission is used by PlatformServices (from code references) → shared
    /// 3. If a permission is used by more than one service → shared
    /// 4. Otherwise → service-specific
    /// </remarks>
    private static string ClassifyScope(PermissionDefinition permission)
    {
        var resource = permission.Resource ?? string.Empty;

        // Rule 1: Platform-level resources
        if (resource.StartsWith("tenant-", StringComparison.OrdinalIgnoreCase) ||
            resource.StartsWith("platform", StringComparison.OrdinalIgnoreCase) ||
            resource.StartsWith("rbac", StringComparison.OrdinalIgnoreCase) ||
            resource.StartsWith("permissions", StringComparison.OrdinalIgnoreCase) ||
            resource.StartsWith("roles", StringComparison.OrdinalIgnoreCase))
        {
            return "Shared";
        }

        // Rule 2: Used by PlatformServices (code-referenced from PlatformServices namespace)
        if (permission.Services.Contains("PlatformServices", StringComparer.OrdinalIgnoreCase))
        {
            return "Shared";
        }

        // Rule 3: Cross-service usage
        if (permission.Services.Count > 1)
        {
            return "Shared";
        }

        // Default: service-specific
        return "ServiceSpecific";
    }
}
