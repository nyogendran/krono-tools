using System.Text;
using PermissionScanner.Core.Models;

namespace PermissionScanner.Core.Services;

/// <summary>
/// Generates FluentMigrator migration files for assigning permissions to roles.
/// </summary>
public class RoleAssignmentGenerator
{
    /// <summary>
    /// Generates a migration file for assigning permissions to roles.
    /// </summary>
    public static string GenerateRoleAssignmentMigrationFile(
        string resourceName,
        List<PermissionDefinition> permissions,
        Dictionary<string, List<PermissionDefinition>> rolePermissions,
        long migrationTimestamp)
    {
        var sb = new StringBuilder();
        
        // Class name: Assign{Resource}PermissionsToRoles
        var className = GenerateClassName(resourceName);
        var migrationNumber = migrationTimestamp;
        
        // File header
        sb.AppendLine("using FluentMigrator;");
        sb.AppendLine();
        sb.AppendLine("namespace KS.MigrationService.Migrations.Stage2_IdentityAccess;");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Assigns {resourceName} permissions to roles for role-based access control");
        sb.AppendLine($"/// Auto-generated by Permission Scanner Tool - DO NOT EDIT MANUALLY");
        sb.AppendLine($"/// Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"[Migration({migrationNumber})]");
        sb.AppendLine($"public class {className} : BaseMigration");
        sb.AppendLine("{");
        sb.AppendLine("    public override void PerformUpgrade()");
        sb.AppendLine("    {");
        sb.AppendLine("        var schemaName = GetAppSchemaName();");
        sb.AppendLine("        ");
        
        // Generate role assignments
        foreach (var (roleName, rolePerms) in rolePermissions.OrderBy(kvp => kvp.Key))
        {
            if (rolePerms.Count == 0)
                continue;
            
            var rolePattern = RoleAssignmentAnalyzer.RolePatterns[roleName];
            sb.AppendLine($"        // {CapitalizeFirst(roleName)} Role: {rolePattern.Description}");
            sb.AppendLine("        Execute.Sql($@\"");
            sb.AppendLine("            INSERT INTO {schemaName}.role_permissions (role_id, permission_id, granted_at, created_at, updated_at, version)");
            sb.AppendLine("            SELECT r.role_id, p.permission_id, NOW(), NOW(), NOW(), 1");
            sb.AppendLine("            FROM {schemaName}.roles r");
            sb.AppendLine("            CROSS JOIN {schemaName}.permissions p");
            sb.AppendLine($"            WHERE r.role_name = '{roleName}'");
            sb.AppendLine("            AND p.is_active = true");
            sb.AppendLine("            AND p.permission_name IN (");
            
            // Generate permission name list
            for (int i = 0; i < rolePerms.Count; i++)
            {
                var perm = rolePerms[i];
                var isLast = i == rolePerms.Count - 1;
                sb.Append($"                '{perm.PermissionName}'");
                if (!isLast)
                    sb.AppendLine(",");
                else
                    sb.AppendLine();
            }
            
            sb.AppendLine("            )");
            sb.AppendLine("            ON CONFLICT (role_id, permission_id) DO NOTHING;");
            sb.AppendLine("        \");");
            sb.AppendLine();
        }
        
        sb.AppendLine("        Console.WriteLine(\"✅ Assigned " + resourceName + " permissions to roles:\");");
        foreach (var (roleName, rolePerms) in rolePermissions.OrderBy(kvp => kvp.Key))
        {
            if (rolePerms.Count > 0)
            {
                sb.AppendLine($"        Console.WriteLine(\"   - {CapitalizeFirst(roleName)}: {rolePerms.Count} permission(s)\");");
            }
        }
        sb.AppendLine("    }");
        sb.AppendLine("    ");
        sb.AppendLine("    public override void PerformDowngrade()");
        sb.AppendLine("    {");
        sb.AppendLine("        var schemaName = GetAppSchemaName();");
        sb.AppendLine("        ");
        sb.AppendLine("        // Remove role permission assignments");
        sb.AppendLine("        Execute.Sql($@\"");
        sb.AppendLine("            DELETE FROM {schemaName}.role_permissions");
        sb.AppendLine("            USING {schemaName}.roles r, {schemaName}.permissions p");
        sb.AppendLine("            WHERE role_permissions.role_id = r.role_id");
        sb.AppendLine("              AND role_permissions.permission_id = p.permission_id");
        sb.AppendLine("              AND p.permission_name IN (");
        
        // Generate permission name list for DELETE
        for (int i = 0; i < permissions.Count; i++)
        {
            var permission = permissions[i];
            var isLast = i == permissions.Count - 1;
            sb.Append($"                '{permission.PermissionName}'");
            if (!isLast)
                sb.AppendLine(",");
            else
                sb.AppendLine();
        }
        
        sb.AppendLine("            );");
        sb.AppendLine("        \");");
        sb.AppendLine("        ");
        sb.AppendLine($"        Console.WriteLine(\"✅ Removed {resourceName} permission assignments from roles\");");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    /// <summary>
    /// Generates a class name from resource name (e.g., "products" → "AssignProductPermissionsToRoles").
    /// </summary>
    private static string GenerateClassName(string resourceName)
    {
        // Convert "products:variants" → "ProductsVariants"
        var parts = resourceName.Split(':', '-');
        var className = string.Join("", parts.Select(CapitalizeFirst));
        return $"Assign{className}PermissionsToRoles";
    }

    /// <summary>
    /// Capitalizes the first letter of a string.
    /// </summary>
    private static string CapitalizeFirst(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;
        
        if (text.Length == 1)
            return text.ToUpper();
        
        return char.ToUpper(text[0]) + text.Substring(1);
    }
}
